<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SkyTrack</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #map { height: 100vh; }

    .hud {
      position: absolute;
      z-index: 9999;
      top: 10px; left: 10px;
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,.12);
      max-width: 320px;
    }
    .hud b { display:block; margin-bottom:4px; }
    .hud small { color:#444; }

    .leaflet-control-mypos button{
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 10px;
      background: rgba(255,255,255,.92);
      box-shadow: 0 6px 20px rgba(0,0,0,.12);
      cursor: pointer;
      font-size: 18px;
      line-height: 40px;
    }
    .leaflet-control-mypos button:hover{
      background: rgba(255,255,255,1);
    }

    .planeWrap { width: 32px; height: 32px; }
  </style>
</head>

<body>
  <div class="hud">
    <b>SkyTrack</b>
    <small id="status">Chargement‚Ä¶</small>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-rotatedmarker/leaflet.rotatedMarker.js"></script>

  <script>
    // =========================
    // Carte + UI
    // =========================
    const map = L.map('map').setView([20, 0], 2); // fallback monde

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    const statusEl = document.getElementById('status');
    const markers = new Map();

    // =========================
    // Ic√¥ne avion jaune/orang√© (SVG) sans contour (anti rouge)
    // =========================
    const planeIcon = L.divIcon({
      className: '',
      html: `
        <div class="planeWrap">
          <svg width="32" height="32" viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
              fill="#FFA500" stroke="none" stroke-width="0"
              style="display:block;">
            <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3-1 3 1v-1.5L13 19v-5.5l8 2.5z"
                  fill="#FFA500" stroke="none" stroke-width="0"/>
          </svg>
        </div>
      `,
      iconSize: [32, 32],
      iconAnchor: [16, 16]
    });

    // =========================
    // Position utilisateur
    // =========================
    let myPosMarker = null;
    let myPosCircle = null;

    function showMyPosition(lat, lon, accuracyMeters) {
      const latlng = [lat, lon];

      if (!myPosMarker) {
        myPosMarker = L.circleMarker(latlng, {
          radius: 6,
          weight: 2,
          opacity: 1,
          fillOpacity: 0.8
        }).addTo(map);
        myPosMarker.bindPopup("Ma position");
      } else {
        myPosMarker.setLatLng(latlng);
      }

      if (accuracyMeters != null && !Number.isNaN(accuracyMeters)) {
        const r = Math.max(accuracyMeters, 25);
        if (!myPosCircle) {
          myPosCircle = L.circle(latlng, {
            radius: r,
            weight: 1,
            opacity: 0.5,
            fillOpacity: 0.08
          }).addTo(map);
        } else {
          myPosCircle.setLatLng(latlng);
          myPosCircle.setRadius(r);
        }
      }
    }

    function locateAndCenter({ center = true } = {}) {
      if (!("geolocation" in navigator)) {
        statusEl.textContent = "G√©olocalisation non dispo";
        return;
      }
      statusEl.textContent = "Localisation‚Ä¶";

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const acc = pos.coords.accuracy;

          showMyPosition(lat, lon, acc);
          if (center) map.setView([lat, lon], Math.max(map.getZoom(), 7));

          // Recharge avions apr√®s centrage
          refresh();
        },
        () => {
          statusEl.textContent = "Localisation refus√©e / indisponible";
        },
        { enableHighAccuracy: false, timeout: 6000, maximumAge: 60000 }
      );
    }

    // Centrage au chargement (si autoris√©)
    locateAndCenter({ center: true });

    // Bouton "Recentrer sur moi"
    const MyPosControl = L.Control.extend({
      options: { position: 'topright' },
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-control leaflet-control-mypos');
        const btn = L.DomUtil.create('button', '', container);
        btn.type = 'button';
        btn.title = 'Recentrer sur moi';
        btn.innerHTML = 'üìç';

        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.on(btn, 'click', (e) => {
          L.DomEvent.preventDefault(e);
          locateAndCenter({ center: true });
        });

        return container;
      }
    });
    map.addControl(new MyPosControl());

    // =========================
    // Avions: markers + rotation
    // =========================
    function upsertMarker(id, lat, lon, heading, label) {
      const rot = (heading == null || Number.isNaN(heading)) ? 0 : heading;
      let m = markers.get(id);

      if (!m) {
        m = L.marker([lat, lon], {
          icon: planeIcon,
          rotationAngle: rot,
          rotationOrigin: "center center"
        }).addTo(map);
        markers.set(id, m);
      } else {
        m.setLatLng([lat, lon]);
        if (m.setRotationAngle) m.setRotationAngle(rot);
      }

      m.bindPopup(label);
    }

    // =========================
    // Fetch robuste: 2 proxys + anti-spam
    // =========================
    let inFlight = false;
    let lastFetch = 0;

    function buildProxyUrls(bbox) {
      const upstream = `https://opensky-network.org/api/states/all?${bbox}`;
      const u = encodeURIComponent(upstream);

      // Proxy 1
      const p1 = `https://corsproxy.io/?${u}`;
      // Proxy 2 (fallback)
      const p2 = `https://api.allorigins.win/raw?url=${u}`;

      return [p1, p2];
    }

    async function fetchWithFallback(urls) {
      let lastErr = null;

      for (const url of urls) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) {
            const t = await res.text().catch(() => "");
            throw new Error(`HTTP ${res.status} ${t.slice(0, 80)}`);
          }
          return await res.json();
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error("Fetch failed");
    }

    async function refresh() {
      const now = Date.now();
      if (inFlight) return;
      if (now - lastFetch < 8000) return; // min 8s entre 2 appels
      lastFetch = now;

      try {
        inFlight = true;

        const b = map.getBounds();
        const bbox =
          `lamin=${b.getSouth()}&lomin=${b.getWest()}` +
          `&lamax=${b.getNorth()}&lomax=${b.getEast()}`;

        statusEl.textContent = "Chargement avions‚Ä¶";

        const urls = buildProxyUrls(bbox);
        const data = await fetchWithFallback(urls);

        const states = data.states || [];
        statusEl.textContent = `Avions visibles: ${states.length}`;

        const seen = new Set();

        for (const s of states) {
          const icao24 = s[0];
          const callsign = (s[1] || "").trim() || icao24;
          const lon = s[5], lat = s[6];
          const heading = s[10];
          const alt = s[13];

          if (lat == null || lon == null) continue;

          const label =
            `<b>${callsign}</b><br>` +
            `ICAO24: ${icao24}<br>` +
            `HDG: ${heading ?? "?"}<br>` +
            `ALT: ${alt ?? "?"}`;

          upsertMarker(icao24, lat, lon, heading, label);
          seen.add(icao24);
        }

        // Nettoyage: enl√®ve ceux qui ne sont plus renvoy√©s
        for (const [id, m] of markers.entries()) {
          if (!seen.has(id)) {
            map.removeLayer(m);
            markers.delete(id);
          }
        }

      } catch (e) {
        statusEl.textContent = `Erreur API/proxy (${String(e.message).slice(0, 60)})`;
        console.log(e);
      } finally {
        inFlight = false;
      }
    }

    // Refresh quand tu bouges/zoomes, mais prot√©g√© par anti-spam
    map.on('moveend zoomend', refresh);

    // D√©marrage + refresh r√©gulier (plus long pour √©viter rate-limit)
    refresh();
    setInterval(refresh, 30000);
  </script>
</body>
</html>
